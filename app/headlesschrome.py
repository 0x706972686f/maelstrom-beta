#!/usr/bin/python3 
import time
import os
import json
import uuid
import urllib.request
import pythonwhois
import ssl
import socket
from urllib.parse import urlparse
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities

CHROMEDRIVERPATH = "chromedriver-nix-x64-v74"
DESKTOPUSERAGENT = 'user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36'
MOBILEUSERAGENT  = 'user-agent=Mozilla/5.0 (Linux; Android 8.0.0; SM-G965F Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Mobile Safari/537.36'

'''
Class headlesschrome

Functions:
        get_page - attempts to browse to a page and returns a chrome driver object
        get_cookies - prints the cookies that are set in browsing the page
        get_pagetitle - returns the content of the HTML <title></title> tag
        get_pagesource - returns the HTML source of the page
        get_currenturl - returns the URL of the page visited, this can vary from the original URL if the page has been redirected.
        get_logdriver - returns the logs that have been generated by the driver
        get_logbrowser - returns the browser logs generated by the driver
        get_useragent - returns the user agent that was used to browse the page
        get_filedownload - a work in progress, requires setting parameters within the chrome configuration to allow for files to be downloaded.
'''
class headlesschrome(object):
        def __init__(self, url, mobile=False):
                self.chromedriver = CHROMEDRIVERPATH 
                if not url.startswith('http'):
                        raise Exception('URLs need to start with "http"')
                else:
                        self.url = url
                self.mobile = mobile
                if mobile is True:
                        self.chromeoptions = self.set_mobilechromeoptions()
                else:
                        self.chromeoptions = self.set_desktopchromeoptions()
                self.page = self.get_page()

        '''
        Set Functions
        '''
        def set_desktopchromeoptions(self):
                chromeoptions = Options()
                chromeoptions.accept_untrusted_certs = True
                chromeoptions.assume_untrusted_cert_issuer = True
                chromeoptions.add_argument("--headless")
                chromeoptions.add_argument("--disable-ipv6")
                chromeoptions.add_argument("--ignore-certificate-errors")
                chromeoptions.add_argument("--window-size=1920x1080")
                chromeoptions.add_argument(DESKTOPUSERAGENT)
                return chromeoptions

        def set_mobilechromeoptions(self):
                mobile_emulation = { "deviceMetrics": {"width": 360, "height": 640, "pixelRatio": 3.0} }
                chromeoptions = Options()
                chromeoptions.accept_untrusted_certs = True
                chromeoptions.assume_untrusted_cert_issuer = True
                chromeoptions.add_experimental_option("mobileEmulation",mobile_emulation)
                chromeoptions.add_argument("--headless")
                chromeoptions.add_argument("--disable-ipv6")
                chromeoptions.add_argument("--ignore-certificate-errors")
                chromeoptions.add_argument(MOBILEUSERAGENT)
                return chromeoptions

        def set_closesession(self):
                self.page.close

        '''
        Get Functions
        '''
        def get_page(self):
                try:
                        caps = DesiredCapabilities().CHROME
                        caps['pageLoadStrategy'] = 'none'
                        driver = webdriver.Chrome(chrome_options=self.chromeoptions, desired_capabilities=caps, executable_path=self.chromedriver)
                        driver.get(self.url)
                        return driver
                except FileNotFoundError:
                        sys.exit(1)
                #return driver

        def get_cookies(self):
                return self.page.get_cookies()

        def get_pagetitle(self):
                return self.page.title

        def get_pagesource(self):
                return self.page_source

        def get_pagescreenshot(self):
                if self.mobile is True:
                        screenshotname = 'app/static/' + str(uuid.uuid3(uuid.NAMESPACE_DNS, self.url)) + '_m.png'
                else:
                        screenshotname = 'app/static/' + str(uuid.uuid3(uuid.NAMESPACE_DNS, self.url)) + '_d.png'
                self.page.get_screenshot_as_file(screenshotname)

        def get_currenturl(self):
                return self.page.current_url

        def get_logdriver(self):
                return self.page.get_log('driver')
        
        def get_logbrowser(self):
                return self.page.get_log('browser')

        def get_useragent(self):
                if self.mobile is True:
                        return MOBILEUSERAGENT
                else:
                        return DESKTOPUSERAGENT

        def get_filedownload(self):
                pass
    
'''
Class hostinformation 
'''
class hostinformation(object):
        def __init__(self, url):
                self.url = url
                self.ip_address = self.set_ipaddress()


        """
        Set Functions
        """
        def set_ipaddress(self):
                # Need to just get the domains/subdomains
                parsed_url = urlparse(self.url)
                domain = '{uri.netloc}'.format(uri=parsed_url)
                addresses = socket.gethostbyname_ex(domain)[2][0]

                #Python Library ipwhois would provide more information on the address block
                return addresses

        """
        Get Functions
        """
        def get_ipaddress(self):
                return self.ip_address

        def get_whois(self):
                # Need to just get the domains/subdomains, to achieve this we add http to the start, then use urlparse to grab the netloc
                parsed_url = urlparse(self.url)
                domain = '{uri.netloc}'.format(uri=parsed_url)
                lookup = pythonwhois.get_whois(domain)
                return lookup

        def get_ipwhois(self):
                lookup = pythonwhois.get_whois(self.ip_address)
                return lookup

        def get_httpheaders(self):
                results = {}
                request = urllib.request.Request(self.url, headers={'User-Agent': DESKTOPUSERAGENT}, method='HEAD')
                response = urllib.request.urlopen(request)

                # Converting from urllib object to dictionary
                for element in response.info().keys():
                                results[element] = response.info()[element]
                return results  

        def get_sslcertificate(self):
                result = {}

                # Need to just get the domains/subdomains 
                parsed_url = urlparse(self.url)
                domain = '{uri.netloc}'.format(uri=parsed_url)

                # Need to create a custom context due to some of the dodginess of the certificates we may encounter
                context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
                # Some sites may have dodgy information, so need to ignore validation
                context.verify_mode = ssl.CERT_OPTIONAL
                context.check_hostname = False
                context.load_default_certs()

                # Not sure how this will go on a HTTP only domain, tried neverssl.com and that returned a cert
                s = context.wrap_socket(socket.socket(), server_hostname=domain)
                s.connect((domain, 443))
                cert = s.getpeercert()

                # The SSL Certificate is displayed in the worst format, it's made up of series of tuples.
                # I could use the following code to get just the items from the subject component of the
                # certificate, but the issuer field also has the same. 
                #
                # result['subject'] = dict(x[0] for x in cert['subject'])
                #
                # To compensate for it, I do the following:
                if cert:
                        keys = cert.keys()
                        trickykeys = ['subject', 'issuer']
                        tmp = []
                        i=0

                        for key in keys:
                              if key in trickykeys:
                                      for i in range(len(cert[key])):
                                              tmp.append(cert[key][i][0])

                        for item in trickykeys:
                                for i in range(len(cert[item])):
                                        if keys not in trickykeys:
                                                tmp.append(cert[item][i][0])
      
                        fixed = dict(tmp)

                        return fixed
                elif not cert:
                        outcome = "No Certificate Present"
                        return outcome











